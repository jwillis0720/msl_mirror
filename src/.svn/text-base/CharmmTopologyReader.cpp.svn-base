/*
----------------------------------------------------------------------------
This file is part of MSL (Molecular Software Libraries) 
 Copyright (C) 2008-2012 The MSL Developer Group (see README.TXT)
 MSL Libraries: http://msl-libraries.org

If used in a scientific publication, please cite: 
 Kulp DW, Subramaniam S, Donald JE, Hannigan BT, Mueller BK, Grigoryan G and 
 Senes A "Structural informatics, modeling and design with a open source 
 Molecular Software Library (MSL)" (2012) J. Comput. Chem, 33, 1645-61 
 DOI: 10.1002/jcc.22968

This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, 
 USA, or go to http://www.gnu.org/copyleft/lesser.txt.
----------------------------------------------------------------------------
*/


#include "CharmmTopologyReader.h"

using namespace MSL;
using namespace std;


CharmmTopologyReader::CharmmTopologyReader() {
	setup();
}

CharmmTopologyReader::CharmmTopologyReader(const string & _filename) {
	setup();
	charmmFileName = _filename;
	open(charmmFileName);
}

CharmmTopologyReader::CharmmTopologyReader(const CharmmTopologyReader & _top) {
	copy(_top);
}

CharmmTopologyReader::~CharmmTopologyReader() {
	deletePointers();
}

void CharmmTopologyReader::operator=(const CharmmTopologyReader & _top) {
	reset();
	copy(_top);
}

void CharmmTopologyReader::deletePointers() {
	for (vector<CharmmTopologyResidue*>::iterator k=residues.begin(); k!=residues.end(); k++) {
		delete *k;
	}
	residues.clear();
	residueMap.clear();
	foundResidue = residueMap.end();
}

void CharmmTopologyReader::setup() {
	defaultFirstPatch = "";
	defaultLastPatch = "";
	autoGenerateAngles = false;
	autoGenerateDihedrals = false;
	foundResidue = residueMap.end();
	residues.push_back(new CharmmTopologyResidue("NONE", true, 0.0, "", ""));
	residueMap["NONE"] = residues.back();
	charmmFileName = "";
}

void CharmmTopologyReader::copy(const CharmmTopologyReader & _top) {
	deletePointers();
	charmmVersion = _top.charmmVersion;
	charmmSubVersion = _top.charmmSubVersion;
	defaultFirstPatch = _top.defaultFirstPatch;
	defaultLastPatch = _top.defaultLastPatch;
	masses = _top.masses;
	autoGenerateAngles = _top.autoGenerateAngles;
	autoGenerateDihedrals = _top.autoGenerateDihedrals;
	deletePointers();
	for (vector<CharmmTopologyResidue*>::const_iterator k=_top.residues.begin(); k!=_top.residues.end(); k++) {
		residues.push_back(new CharmmTopologyResidue(**k));
		residueMap[residues.back()->getName()] = residues.back();
	}
	foundResidue = residueMap.end();
}


void CharmmTopologyReader::reset() {
	deletePointers();
	residues.push_back(new CharmmTopologyResidue("NONE", true, 0.0, "", ""));
	residueMap["NONE"] = residues.back();
	charmmVersion.clear();
	defaultFirstPatch = "";
	defaultLastPatch = "";
	masses.clear();
	autoGenerateAngles = false;
	autoGenerateDihedrals = false;
}

bool CharmmTopologyReader::read() {

	if (!is_open()) {
		return false;
	}



	vector<vector<string> > splitFile;
	try { 
		vector<string> lines;
		while (!endOfFileTest()){

			string line = Reader::getLine();
			if (line[0] == '*') {
				// skip title
				continue;
			}
			line = MslTools::toUpper(line);
			lines.push_back(line);
		}

		lines = MslTools::uncomment(lines, "!");
		lines = MslTools::joinConnectedLines(lines, "-");
		for (unsigned int i=0; i<lines.size(); i++) {
			vector<string> tokens = MslTools::tokenize(lines[i]," \t");  
			if (tokens.size() > 0) {
				splitFile.push_back(tokens);
			}
		}

		bool foundResidue_flag = false;
		int groupCount = -1;
		for (vector<vector<string> >::iterator k=splitFile.begin(); k!=splitFile.end(); k++) {
			if (k - splitFile.begin() == 0) {
				// capture the charmm version on the first non title, non blank line
				charmmVersion = (*k)[0];
				if (k->size() > 1) {
					charmmSubVersion = (*k)[1];
				}
				continue;
			}
			// NEW RESIDUE DEFINITION
			if ((*k)[0].substr(0, 4) == "MASS") {
				if (k->size() >= 5) {
					AtomMass tmp;
					tmp.index = MslTools::toInt((*k)[1]);
					tmp.atomName = (*k)[2];
					tmp.mass = MslTools::toDouble((*k)[3]);
					tmp.element = (*k)[4];
					masses[(*k)[2]] = tmp;
				}
			} else if ((*k)[0].substr(0, 4) == "DEFA") {
				if (k->size() >= 3 && (*k)[1].substr(0, 4) == "FIRS") {
					defaultFirstPatch = (*k)[2];
				}
				if (k->size() >= 5 && (*k)[3].substr(0, 4) == "LAST") {
					defaultLastPatch = (*k)[4];
				}
			} else if ((*k)[0].substr(0, 4) == "AUTO") {
				for (vector<string>::iterator l=k->begin()+1; l!=k->end(); l++) {
					if (l->substr(0,4) == "ANGL" || l->substr(0,4) == "THET") {
						autoGenerateAngles = true;
					} else if (l->substr(0,4) == "DIHE" || l->substr(0,4) == "PHI") {
						autoGenerateDihedrals = true;
					}
				}
			} else if ((*k)[0].substr(0, 4) == "DECL") {
				// do nothing
			} else if ((*k)[0].substr(0, 4) == "RESI" || (*k)[0].substr(0, 4) == "PRES") {
				if (k->size() >= 3) {
					foundResidue_flag = true;
					string residueName = (*k)[1];
					double residueCharge = MslTools::toDouble((*k)[2]);
					if ((*k)[0].substr(0, 4) == "RESI") {
						// a RESI
						residues.push_back(new CharmmTopologyResidue(residueName, false, residueCharge));
						residueMap[residueName] = residues.back();
						foundResidue = residueMap.end();
						residues.back()->setFirstDefaultPatch(defaultFirstPatch);
						residues.back()->setLastDefaultPatch(defaultLastPatch);
					} else {
						// a PRES
						residues.push_back(new CharmmTopologyResidue(residueName, true, residueCharge));
						residueMap[residueName] = residues.back();
						foundResidue = residueMap.end();
					}
					groupCount = -1;
				}
			} else if ((*k)[0].substr(0, 4) == "GROU") {
				if (!foundResidue_flag) {
					cerr << "Invalid GROUP statement outside residue in topology file" << endl;
					return false;
				}
				groupCount++;
			} else if ((*k)[0].substr(0, 4) == "ATOM") {
				if (!foundResidue_flag) {
					cerr << "Invalid ATOm statement outside residue in topology file" << endl;
					return false;
				}
				if (k->size() >= 4) {
					if (groupCount == -1) {
						// if no GROUP was given, we forgive it
						groupCount++;
					}
					map<string, AtomMass>::iterator found = masses.find((*k)[2]);
					string element = "";
					if (found != masses.end()) {
						element = found->second.element;
					}
					residues.back()->addTopolAtom((*k)[1], (*k)[2], MslTools::toDouble((*k)[3]), element, groupCount);

				}
			} else if ((*k)[0].substr(0, 4) == "BOND") {
				if (!foundResidue_flag) {
					cerr << "Invalid BOND statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 1) {
					residues.back()->addBond((*k)[0], (*k)[1], 1);
					//cout << "1: " << (*k)[0] << " " << (*k)[1] << endl;
					k->erase(k->begin(), k->begin()+2);
				}
			} else if ((*k)[0].substr(0, 4) == "DOUB") {
				if (!foundResidue_flag) {
					cerr << "Invalid DOUBLE statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 1) {
					residues.back()->addBond((*k)[0], (*k)[1], 2);
					//cout << "2: " << (*k)[0] << " " << (*k)[1] << endl;
					k->erase(k->begin(), k->begin()+2);
				}
			} else if ((*k)[0].substr(0, 4) == "TRIP") {
				if (!foundResidue_flag) {
					cerr << "Invalid TRIPLE statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 1) {
					residues.back()->addBond((*k)[0], (*k)[1], 2);
					//cout << "3: " << (*k)[0] << " " << (*k)[1] << endl;
					k->erase(k->begin(), k->begin()+2);
				}
			} else if ((*k)[0].substr(0, 4) == "ANGL" || (*k)[0].substr(0, 4) == "THET") {
				if (!foundResidue_flag) {
					cerr << "Invalid ANGLE statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 2) {
					residues.back()->addAngle((*k)[0], (*k)[1], (*k)[2]);
					//cout << "A: " << (*k)[0] << " " << (*k)[1] << " " << (*k)[2] << endl;
					k->erase(k->begin(), k->begin()+3);
				}
			} else if ((*k)[0].substr(0, 4) == "DIHE" || (*k)[0].substr(0, 4) == "PHI") {
				if (!foundResidue_flag) {
					cerr << "Invalid DIHEDRAL statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 3) {
					residues.back()->addDihedral((*k)[0], (*k)[1], (*k)[2], (*k)[3]);
					//cout << "D: " << (*k)[0] << " " << (*k)[1] << " " << (*k)[2] << " " << (*k)[3] << endl;
					k->erase(k->begin(), k->begin()+4);
				}
			} else if ((*k)[0].substr(0, 4) == "IMPR" || (*k)[0].substr(0, 4) == "IMPH") {
				if (!foundResidue_flag) {
					cerr << "Invalid IMPROPER statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 3) {
					residues.back()->addImproper((*k)[0], (*k)[1], (*k)[2], (*k)[3]);
					//cout << "I: " << (*k)[0] << " " << (*k)[1] << " " << (*k)[2] << " " << (*k)[3] << endl;
					k->erase(k->begin(), k->begin()+4);
				}
			} else if ((*k)[0].substr(0, 4) == "DONO") {
				if (!foundResidue_flag) {
					cerr << "Invalid DONOR statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 1) {
					residues.back()->addDonor((*k)[0], (*k)[1]);
					//cout << "Don: " << (*k)[0] << " " << (*k)[1] << endl;
					k->erase(k->begin(), k->begin()+2);
				}
			} else if ((*k)[0].substr(0, 4) == "ACCE") {
				if (!foundResidue_flag) {
					cerr << "Invalid ACCEPTOR statement outside residue in topology file" << endl;
					return false;
				}
				k->erase(k->begin());
				while (k->size() > 1) {
					residues.back()->addAcceptor((*k)[0], (*k)[1]);
					//cout << "Acc: " << (*k)[0] << " " << (*k)[1] << endl;
					k->erase(k->begin(), k->begin()+2);
				}
			} else if ((*k)[0].substr(0, 4) == "IC" || (*k)[0].substr(0, 4) == "BUIL" || (*k)[0].substr(0, 4) == "BILD") {
				if (!foundResidue_flag) {
					cerr << "Invalid IC statement outside residue in topology file" << endl;
					return false;
				}
				if (k->size() >= 10) {
					string atom1 = (*k)[1];
					string atom2 = (*k)[2];
					string atom3 = (*k)[3];
					string atom4 = (*k)[4];
					double d1    = MslTools::toDouble((*k)[5]);
					double a1    = MslTools::toDouble((*k)[6]);
					double dihe  = MslTools::toDouble((*k)[7]);
					double a2    = MslTools::toDouble((*k)[8]);
					double d2    = MslTools::toDouble((*k)[9]);
					bool impr = false;
					if (atom3.substr(0,1) == "*") {
						impr = true;
						atom3 = atom3.substr(1, atom3.length()-1);
					}
					residues.back()->addIcLine(atom1, atom2, atom3, atom4, d1, a1, dihe, a2, d2, impr);
					//cout << "IC: " << atom1 << " " << atom2 << " " << atom3 << " " << atom4 << " " << d1 << " " << a1 << " " << dihe << " " << a2 << " " << d2 << " " << impr << endl;
				}
			} else if ((*k)[0].substr(0, 4) == "DELE") {
				if (!foundResidue_flag) {
					cerr << "Invalid DELETE statement outside residue in topology file" << endl;
					return false;
				}
				if (k->size() > 1) {
					string type = (*k)[1].substr(0,4);
					k->erase(k->begin(), k->begin()+2);
					vector<string> atoms;
					for (vector<string>::iterator l=k->begin(); l!=k->end(); l++) {
						atoms.push_back(*l);
					}
					residues.back()->addDelete(type, atoms);
				}
			} else if ((*k)[0].substr(0, 4) == "PATC") {
				if (!foundResidue_flag) {
					cerr << "Invalid PATCHING statement outside residue in topology file" << endl;
					return false;
				}
				if (k->size() > 2) {
					if ((*k)[1].substr(0, 4) == "FIRS") {
						residues.back()->setFirstDefaultPatch((*k)[2]);
					} else if ((*k)[1].substr(0, 4) == "LAST") {
						residues.back()->setLastDefaultPatch((*k)[2]);
					}
					if (k->size() > 4) {
						if ((*k)[3].substr(0, 4) == "FIRS") {
							residues.back()->setFirstDefaultPatch((*k)[4]);
						} else if ((*k)[3].substr(0, 4) == "LAST") {
							residues.back()->setLastDefaultPatch((*k)[4]);
						}
					}
				}
			} else if ((*k)[0].substr(0, 4) == "END") {
				break;
			} else {
				cerr << "Unknow identified " << (*k)[0] << " in topology file";
				return false;
			}

		}
			

	} catch(...){
		cerr << "ERROR 8123 in void CharmmTopologyReader::read()\n";
		exit(8123);
	}

	return true;
}
